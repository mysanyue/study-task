# 模块二：ES新特性与TypeScript、Js性能优化

### 一、请说出下列最终的执行结果，并解释为什么

``` js
var a = [];

for (var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i);
  }
}

a[6]();
```

首先，全局定义变量 `a` ， `i` 。然后赋值 `a` 为一个空数组， `i` 为 `0` 。执行代码， `for` 循环添为 `a` 数组添加元素类型为 `function` ，并传入循环变量 `i` ，由于这里 `i` 为全局变量，所以当循环体结束 `i=10` 。由于 `a` 数组里放法所有的 `i` 都指向全局 `i` ，所以 `a[6]()` 的结果为 `10`

### 二、请说出下列最终的执行结果，并解释为什么

``` js
var tmp = 123;

if (true) {
  console.log(tmp);
  let tmp;
}
```

全局定义变量 `tmp` ，赋值 `123` , 然后执行条件判断 `if` ，由于 `if` 语句出现花括号（为局部作用域），并且里面声明变量 `let` 且 `let` 不存在变量提升，由于局部作用域声明了 `tmp` ，所以会屏蔽全局作用域 `tmp` ，由于 `tmp` 在未声明前使用，所以会报错

### 三、结合ES6最新语法，用最简单的方式找出数值中的最小值

``` js
var arr = [12, 34, 32, 89, 4];

var min = Math.min(...arr);
```

### 四、请详细说明 var、let、const 三种声明变量的方式之间的具体差异

* `var` 不是块级作用域，存在变量提升，存在全局污染。
* `let`、`const` 块级作用域，不存在变量提升。
* `const` 变量一旦声明之后，不允许再被修改。声明的同时必须要赋值。
* `const` 声明之后不允许修改只是不允许指向新的内存地址，并不是说不允许修改属性成员。

### 五、请说出下列代码最终输出的结果，并解释为什么

``` js
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    })
  }
}
obj.fn();
```

首选全局定义变量 `a` 、对象 `obj` ，然后 `a` 赋值 `10` ， `obj` 中 `a = 5` ， `fn` 是一个函数，这个函数执行一个异步任务。调用函数 `obj.fn()` ，由于这里没有微任务，所以继续执行异步任务，这里由于使用了箭头函数，所以 `this` 为外层作用域 `this` ，所以 `this` 指向 `obj` ，打印为 `20`

### 六、简述 Symbol 类型的用途

* 创建一个独一无二的值
* 创建一个私有成员
* 扩展对象和函数

### 七、说说什么是浅拷贝，什么是深拷贝

浅拷贝即地址拷贝，让目标对象指向同一个内存空间，目标对象修改会影响原始对象，深拷贝即原型原型链拷贝，拷贝对象的具体内容，两个对象一样，但实际内存地址不一样，不会影响原始对象。

### 八、请简述 TypeScript 与 JavaScript 之间的关系

`TypeScript` 是 `JavaScript` 的一个超集，是 `JavaScript` 脚本语言的增强版本

### 九、请谈谈你认为的 TypeScript 优缺点

* 学习成本略高
* 会增加一些开发成本
* 和一些库集合不是很完美 

### 十、描述引用计数的工作原理和优缺点

* 核心思想：设置引用数，判断当前引用数是否为0
* 引用计数器
* 引用关系改变时修改引用数字
* 引用数字为0时立即回收

  > 优点

  + 发现垃圾时立即回收
  + 最大限度减少程序暂停

  > 缺点

  + 无法回收循环引用的对象
  + 时间开销大

### 十一、描述标记整理算法的工作流程

1. 遍历所有对象找标记活动对象
2. 遍历所有对象清除没有标记对象
3. 回收相应的空间
4. 清除阶段会先执行整理，移动对象位置

### 十二、描述V8中新生代存储区垃圾回收的流程

1. 回收过程采用复制算法 + 标记整理算法
2. 新生代内存区分为二个等大小空间
3. 使用空间为 `From`，空闲空间为 `To`
4. 活动对象存储与 `From` 空间
5. 标记整理后将活动对象拷贝至 `To`
6. `From` 与 `To` 交换空间完成释放

### 十三、描述增量标记算法在何时使用及工作原理

将当前一整段的垃圾操作拆分成多个小部，组合着去完成整个回收，从而替代一口气做完的垃圾回收操作，好处：可以是先垃圾回收与程序交替执行，而不是以前那样程序执行的时候不能做垃圾回收，做垃圾回收的时候程序就不能运行，这样带来的时间消耗更佳合理一些
